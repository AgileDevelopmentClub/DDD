# CH10 しなやかな設計 1




* <b>なぜしなやかな設計が必要か？</b>

    * まず、ソフトウェアはユーザの役に立つ以前に、開発者の役に立たなければならない。
    
        - プログラムが進化するにつれて開発者は再配置、結合を行い、コードの変更と拡張を繰り返す。

    * 複雑なふるまいをするソフトウェアの設計が優れたものでなければ、リファクタリングや複数の要素を結びつけたりすることが困難になる。

    * 過去に作成したレガシーによって押しつぶされないようにし、開発の進行に合わせてプロジェクトを加速させるためには、<b>楽しく仕事ができて変更を呼び込むような設計が欠かせない</b>
        
        - =しなやかな設計

* <b>シンプルに作ることの難しさ</b>

    * オーバーエンジニアリングの多くが柔軟性の名の下に正当化されてきた。

        - 実際は邪魔になることのほうが多い
    
    * シンプルにソフトウェアを作ることは容易ではない。

        - いつでも手の込んだシステムへと組み立てることができる。
        - モデル駆動設計に専念する際に、過度に緻密な設計スタイルが求められる。

    * シンプルにソフトウェアを維持することも容易ではない。

        - 取り入れられたシンプルな設計スタイルは、ソフトウェアを<b>使用する側</b>にも洗練された設計スキルが必要となる。



* <b>開発者の２つの役割</b>
    
    開発者には２つの役割があり、設計はそのどちらに対しても寄与しなければならない。
    <br>

    - 作成する側（クライアント開発者）
    
        - 設計を活用しながら、ドメインオブジェクトをコードに織り込んでいく。
    
        - 疎結合した概念を最低限あつめたものを柔軟に使用して、ドメインにおける幅広いシナリオを表現する。

    <br>

    - 使用する側（ソフトウェアを変更しようとする開発者）

        - 変更を受け入れやすくするには、設計は容易に理解できていなければならず、根底にあるクライアント開発者が利用しているのと同じモデルを明らかにしなければならない。

        - ほとんどの変更はコードの柔軟な設計を曲げることになる。

---

### しなやかな設計に貢献するパターン

* <b>意図の明白なインタフェース(INTENTION-REVEALING INTERFACES)</b>
    
    <br>

    * <b>カプセル化の価値</b>
        * 演算の詳細やルールの細かい部分について多くの理解が必要だが、そういうものをすべてカプセル化することで、クライアントコードはシンプルになり、より高いレベルの概念から解釈が可能となる
        
        <br>

        * オブジェクトのインタフェースから、オブジェクトを有効に使用する上で何を知っているべきかがわからない状態はカプセル化の価値のほとんどを失う
        
           - クライアント開発者は詳細をなんとか理解するためにコードの内部を掘り下げる必要がある。

           - それは保守を行う開発者も同様。
        
    * ある開発者がコンポーネントを使用するために、その実装についてじっくり考えなければならないのであれば、カプセル化の価値は失われる

    <br>

    * <b>カプセル化の価値を獲得するためには、オブジェクトの概念を反映した名前をプログラムに与えなければならない。</b>
        - クラスやメソッドの名前は開発者間のコミュニケーションを高め、システムの抽象化のされ方を改善させる絶好の機会
    
    <br>
    
    * クラスとメソッドにはその効果と目的を記述する名前をつけ、実行する手段には言及しないこと。
    * こうした名前はユビキタス言語に従っていなければならない。
    * ふるまいを作成する前にテストを書き、クライアント開発者の視点で考えられるようにすること
---

* <b>副作用のない関数(SIDE-EFFECT-FREE-FUNCTIONS)</b>
    
    - 副作用とは
        - システムの状態に対するあらゆる変化のうちで将来の操作に影響するもの

    - 副作用のある操作を呼び出す開発者は、結果を予想するために呼び出し先の実装とそれが委譲する実装をすべて理解しなければならない。
        - インタフェースによって隠されたものを見る必要が出てくる

    - 副作用を起こさずに結果を戻す操作は「<b>関数</b>」と呼ばれる。
        - 関数は何度も呼び出すことができ、毎回同じ値を戻すことができる。
            - ネストの深さを気にする必要がない。
            - 副作用のある操作よりもテストがはるかに容易

    - どうしても副作用のある操作が必要となった場合どうするべきか？

        - 変更と取得の分離
            - 変更を引き起こすメソッドに関して、ドメインデータを戻さないようにし、可能な限りシンプルに保つことを保証すること
            - 変更と取得はすべて、目に見える副作用を起こさないメソッドで実行すること

        - オブジェクトを変更する代わりに、処理の結果を表す新しい値オブジェクトを生成して戻す
            - 値オブジェクトは取得に対する回答として生成され、受け渡され、忘れられる。
            - 値オブジェクトは不変であるため、すべての操作が関数であることを示唆する。
        
    - ロジックのうち、できる限り多くの部分を関数に置くこと。
    - オブジェクトへの変更は厳密に分離し、ドメインについての情報を戻さない単純な操作にすること。
    - ある概念が値オブジェクトの担う責務に合致する場合は、複雑なロジックをその値オブジェクトに移すことによって、副作用をさらに制御すること。

    <br>


---

#### 感想

- ito
    - Repository層における意図の明白なインタフェース
        JPAによるデータベースアクセスメソッドはできるだけラッピングして使うべきか？
        例えば findByEntryId()はそのままではメソッドの概念を表さない。
