# CH10 しなやかな設計 2

## 表明（ASSERTIONS）

- 変更と取得の分離
    - クエリ
    - コマンド
        - コマンドを使用する人は結果を理解していなければならない
        - **表明**があることで、副作用が明示的になる
- コマンドが別のコマンドを呼ぶなど、操作の副作用が実装によって暗黙的にしか定義されていない場合、理解のためには具体的なパスを辿る必要があり、カプセル化の価値が失われる
- 表明はどれも手続きではなく状態に関するもの
- **操作の事後条件と、クラス及び集約の不変条件を宣言すること**
    - 書けるなら、表明をドキュメンテーションする
- **表明を直接コーディング出来なければ、自動化されたユニットテストを書くこと**
- モデルがぎこちないと、奇妙な事後条件をドキュメント化するのに行き詰まり、概念の欠如がわかる -> 新しいモデルを探すきっかけに（塗料の例）

## 概念の輪郭（CONCEPTUAL CONTOURS）

- モデルを一枚岩にしてしまうと、インタフェースから意味を理解するのが難しくなる
- クラスやメソッドを分割しすぎると、クライアントを無意味に複雑にするし、概念が失われかねない
- リファクタリングを繰り返すことで、**概念の輪郭**が姿を表す
    - 高凝集と低結合
- 目標はシンプルなインタフェースの集まりを作ること

## 独立したクラス（STANDALONE CLASSES）

- 相互依存関係があると、モデルと設計は理解するのが難しくなる
- モジュールや集約は、相互依存関係の網の目を制限するためのもの
    - 凝集度の高いサブドメインを切り分けてモジュール化すれば、相互に関連する概念の数は限られる
- **低結合はオブジェクト設計の基本。やるときは徹底的に**
    - オブジェクトのイメージから他の概念をすべて取り除く
    - なお、すべての依存関係を取り除くのではなく、本質的でない依存関係を取り除くことが目的
        - 例：「塗料 -> 色」の依存は本質的だが、「色 -> 塗料」の依存は取り除かれるべき。「色」は単独で調査・テストできるべき

## 閉じた操作（CLOSURE OF OPERATIONS）

- $ ∀x ∈ \mathbb{R}, f(x) ∈ \mathbb{R} $：$f$ は $\mathbb{R}$ について閉じている
- **戻り値の型が引数の型と同じにできる場合、そのように操作を定義する**
- そのような操作はインスタンス集合の下に閉じているため、他の依存関係を導入することなく高度なインタフェースを提供できる

## 宣言的な設計

- どんなに明白な表明を行っても、従来のオブジェクト指向に正式な厳密さを与えることは決して出来ない（必ず、手続きを書くことになる）
- **宣言的な設計**は、こうした動機から生まれている
    - コンパイル時のコード生成など（Swagger もそう？）
    - 問題点
        - 表現力はそこまで豊かでない
        - 生成コードに手書きすると、再度自動生成できない
- 特に退屈でエラーを生みやすい設計の側面を自動化する場合、価値がある
    - 永続化や O/R マッピング
    - （Swagger の Validation とか？）
- ドメイン特化言語というアプローチもある
    - ユビキタス言語と最も強く結びつくことができる一方、モデルを改良するために開発者は言語を修正できなければならない

## 設計の宣言的スタイル

- 明白なインタフェース、副作用のない関数、表明が揃うと、宣言的な考え方の領域に近づく
- 宣言的スタイルで仕様を拡張する
    - AND, OR, NOT を組み合わせた仕様の結合
    - 包含

## 攻める角度

- 多くのテクニックを駆使して、巨大なシステムにいきなりしなやかな設計を適用するのは難しい
- 広く適用できるアプローチ
    - サブドメインを切り取る
    - 確立された形式主義を活用する

