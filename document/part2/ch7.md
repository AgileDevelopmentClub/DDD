# 言語を使用する：応用編

当章では、複雑な例を第二章で使用したパターンを用いてどう解決するかを記載する。

## 例：貨物輸送システムを導入する
輸送貨物会社のための新しいソフトウェアを開発する。  
最初は3つの基本的な機能を要求。
- 顧客貨物に対する主要な荷役を追跡する。
- あらかじめ貨物を予約する。
- 貨物が荷役の過程で所定の場所に到達した際に、自動敵に請求書を顧客に送付する。

//  TODO: 図7.1の説明いる？

### ドメインを隔離する：アプリケーションの導入
ドメインの責務が、システムの他の部分が持つ責務と混ざらないように、レイヤ化アーキテクチャを適用してドメイン層を区切る。  

- 特定の貨物に対して行われた過去と現在の荷役にアクセスできる追跡問い合わせ
- 新規の**貨物**を登録できるようにして、それに対してシステムの準備を整える予約アプリケーション
- **貨物**に対して行われた書く荷役を記録できるイベント記録アプリケーション(追跡問い合わせで検索される情報を提供する)

これらのアプリケーションは調停役(coordinator)であり、質問に対する答えを考えてはならない。それはドメイン層の仕事である。


### エンティティと値オブジェクトを区別する
追跡すべき同一性や、表現されている基本的な値を探す。  
まず、明快なケースを見た後に、より曖昧なケースについて検討する。

// TODO

- 顧客
- 貨物
- 荷役イベントと郵送機器移動
- 位置
- 配送記録
- 配送仕様


### 輸送ドメインの関連を設計する
双方向の関連は、設計上問題になる。  
関連をたどれる方向は、ドメインに対する洞察をとらえていることが多く、モデル自体を深めもする。

- 貨物と顧客
    - 貨物すべてに対して、顧客が直接参照を持っていると、顧客が長年のリピータであった場合に扱いにくくなる。  
    顧客の概念は貨物に固有のものではない。  
    巨大なシステムは、顧客には多くのオブジェクトに対して果たす役割があると考えられるので、そういう特定の責務からは解放しておくことが一番。  
    顧客から貨物を検索する機能が必要ならば、データベースクエリで実現できる。
- 輸送機器移動と荷役イベント
    - 船の目録を追跡することが目的なら、輸送機器移動から荷役イベントへ辿ることが重要になるだろうが、今回のアプリでは貨物の追跡で充分。  
    荷役イベントから輸送機器移動への関連のみ辿れるようにするだけでよい。  
- その他の論理的決定は図7.2で説明しているので、そちら参照。
- 循環参照
    - トレードオフ
    貨物が配送記録を知り、配送記録は荷役イベントを保持し、荷役イベントが貨物を参照する。  
    循環参照は、設計上必要だが維持管理しにくい。実装上の選択として、同期させなければならない同じ情報を２か所で持たれないようにすることでうまくいくかもしれない。  
    今回のプロトタイプでは、配送記録に荷役イベントをリストで所持する。  
    いつか、コレクションを止めて、貨物をキーとしたデータベースを行うことにする。  
    リポジトリの選択において、良く取り上げられる。　　
    記録を参照が稀であれば、DBを検索する実装で性能は工場、保守は単純になり、荷役イベントを追加する際のオーバーヘッドも減る。  
    多いの場合は、直接参照を管理する方が適している。
    実装の単純さと性能の間でバランスがとられる。どちらも、モデルは変わらずに循環と双方向の関連を含んでいる。  
### 集約の境界
顧客、位置、輸送機器移動には独自の同一性があって、多くの貨物に共有されている。  
そのため、独自に集約をもって、かつルートになる。
貨物も集約ルートだが、どこに境界を引くかを決めるには検討が必要。  
  
貨物の集約は、配送記録、配送仕様、荷役イベントを含むことになる。  
これは、配送記録によくあてはまる。  
貨物を必要とせずに、配送記録を直接探す人はいないと思えるからだ。  
直接的なアクセスが必要なく、同一性が貨物から派生するだけなので、配送記録は貨物の境界内に収まってルートである必要はない。  
配送仕様は値オブジェクトなので、貨物の集約でも問題ない。  
  
荷役イベントに関しては話が別。  
荷役イベントを検索する2つのデータベースクエリの可能性を考察した。  
1. コレクションの代わりとして、配送記録に関する荷役イベントを見つけるというもので、貨物集約内で閉じることになるだろう。
1. 特定の輸送機器移動に向けて、荷積みと準備を行うすべての業務を見つけるのに使用されるだろう。
後者では、貨物自体から切り離して考えても意味を持つと思われるため、荷役イベントは独自の集約ルートであるべき、という結論。

### リポジトリを選択する
集約のルートとなるエンティティは5つ。  
リポジトリを検討する際には、これらに限定できる。  
他のオブジェクトは、リポジトリを持つことが認められない。  
  
- 予約アプリケーション
    - 予約を取るために配送人、荷受人などの顧客を選択する必要があるので、顧客リポジトリが必要となる。  
    貨物に荷だし知として指定するための位置が必要なので、位置リポジトリを作成する。
- アクティブティ記録アプリケーション
    - ある貨物が積まれた輸送機器移動をユーザが検索できるようにする必要がある多面、輸送機器移動リポジトリが必要。  
    ユーザはどの貨物が荷積みされたかについて、システムに伝えなければならないから、貨物リポジトリも必要。
- 荷役イベントリポジトリは？
    - 最初のイテレーションでは、配送記録との関連をコレクションとして実装しているため、不要。  
    輸送機器移動に、何が荷積みされているかを調べるというアプリケーションの要求が無いからでもある。  
    どちらも変わる可能性があり、変わった場合はリポジトリを追加することになる。  

### シナリオをウォークスルーする
これまでの決定をすべてクロスチェックするためには、常に段階を追ってシナリオを見ながら、アプリケーションの問題を効果的に解決できることを確かめる必要がある。  

#### 機能：貨物の荷だし値を変更する
// TODO


#### 機能：リピータへの対応
// TODO


### オブジェクトの生成
#### 貨物用のファクトリとコンストラクタ
貨物用の手の込んだファクトリがあったり、別の貨物をファクトリとして使用したりする場合でも、プリミティブなコンストラクタは必要。  
そのコンストラクタを用いて生成したいのは、不変条件をを満たしているオブジェクトか、エンティティの場合に少なくとも同一性が侵されていないオブジェクトである。  
これらの決定を踏まえると、次のようなファクトリメソッドを貨物上に作成することになる。

```java
public Cargo copyPrototype(String newTrackingId)
```
あるいは、次のような独立したファクトリにメソッドを作成してもよい。  
```java
public Cargo newCargo(Cargo prototype, String newTrackingId)
```

独立したファクトリは、新規の貨物のために新しいIDを取得するプロセスをカプセルかすることもでき、その場合必要な引数は一つだけとなる。
```java
public Cargo newCargo(Cargo prototype)
```
これらのファクトリが戻す結果はどれも同じ、配送記録がカラで配送使用がnullの貨物である。
貨物と配送記録との間にある、この双方向の関連が意味するのアｈ、貨物も配送記録も相手を参照していなければ完全ではないので、一緒に生成しなければならない。  
貨物が、配送記録を含んだ集約のルートであることを忘れないでほしい。だからこそ、貨物のコンストラクタやファクトリに配送記録を生成させることができる。  
配送記録のコンストラクタは、引数として貨物を取る。  
```java
public Cargo(String id){
    trackingId = id;
    deliveryHistory = new DeliveryHistory(this);
    customerRoles = new HashMap();

}
```
このコンストラクタでは、自らを参照し返す新しい配送記録を持った新規の貨物である。  
配送記録のコンストラクタは、それを含む集約のルート、すなわちかもつによってのみ使用され、それにより貨物の構造がカプセル化される。

#### 荷役イベントを追加する
// TODO

### リファクタリングのために立ち止まる：貨物集約についてのもう一つの設計
// TODO

### 輸送モデルにおけるモジュール
// TODO

### 新機能を導入する：配分チェック
// TODO

### まとめ
// TODO

### 水上疑問点
- DBのテーブルはMVPから複雑なInnerJoinしてあるべき？  
- externalは腐敗防止層？repository