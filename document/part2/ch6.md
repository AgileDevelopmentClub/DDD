# ドメインオブジェクトのライフサイクル

ライフサイクルとは
生成、修正、格納、再構成、アーカイブ、削除とうの状態遷移のこと

### 課題
1. ライフサイクルを通して生合成を維持すること
2. ライフサイクル管理が複雑でも、モデルを侵食しないこと
   
これらを解決するテクニックとして本章では以下３つの概念を説明する

---

## 集約(Aggregates)
---
### 定義
* 密接に関連するオブジェクト間の不変条件をカプセル化する物
* ドメインオブジェクトのトランザクションを制御する範囲
* 複雑な関連を伴うモデルではオブジェクトの一貫性を保証するのが難しい
（慎重にロックしすぎると全然更新できないし、ロックをしないと一貫性が保証できない）＜＝　関連はなるべく少なくなるようにモデリングすべき

集約にはルートと境界がある
外部のオブジェクトが参照していいのはルートだけ（内部をカプセル化している）
集約だけがグローバルな一意性を担保しなければならない
内部のオブジェクトは、集約内でのみ一意であれば良い


* 集約のルートエンティティはグローバルな同一性をもち、不変条件を維持する責任をもつ
* 集約内部のエンティティは集約内部でのみ一意となるローカルな同一性をもつ
* 集約の境界外のオブジェクトは集約のルート以外の参照を保持できない
* 集約内部のオブジェクトは他の集約ルートの参照を保持できる`今の所理解できない`
* 削除の操作は集約内に存在するあらゆるものを一度に削除しなければならない
* 集約内部のオブジェクトが変更がコミットされる場合、集約全体の不変条件が維持されなければならない
  

## ファクトリ（Factory）
複雑な集約を作成する操作を集約自体に持たせると、集約が複雑かする
だからと言ってAP層に持たせるとドメインの知識がドメインから流出してしまう
複雑な集約の作成をカプセル化するのにファクトリを用いる

### ファクトリの要件
* 生成操作はアトミックにすること（不変条件を満たしている）
* ファクトリは生成される具象クラスではなく、要求される肩に応じて抽象化されなければならない`よくわからない`
  
### ファクトリの場所
* 集約のルートにファクトリメソッドとして定義
* 他のオブジェクトの生成に密接に関わるオブジェクトにファクトリメソッドを置く（`よくわからない`）

### コンストラクタで良いケース
* クラスが（type）である（`よくわからん`）
* クライアントが実装に関心がある（ストラテジーを選択する方法の場合）
* オブジェクトの持つ属性を全てクライアントが取得できるため、クライアントが目にするコンストラクタの内部に別のオブジェクトがネストされることがない（`意味不明`）
* 構築が複雑でない
* 公開コンストラクタは不変条件を満たすアトミックな操作でなければならない

### IFの設計
`各操作はアトミックでなければならない`  
不変条件が満たせなかったときにどうなるか、決める必要あり
（NULLを返すのか、例外を出すのか。コーディング基準を決めるとべき）

`ファクトリはその引数と結合する`  
入力パラメータと深く結合するので、慎重にパラメータを決める
なるべくパラメータは抽象化すること

### 不変条件のロジックはどこに置くべきか
ファクトリは不変条件の検証を生成物に委譲できる

（「全く魅力を感じない」＜＝`意味不明`）


  
### エンティティファクトリと値オブジェクトファクトリの違い
値オブジェクトファクトリはオブジェクトを完全な状態で作成する必要があるが、エンティティファクトリは不変条件さえ満たしていれば、あとは大丈夫


### 格納したオブジェクトを再構成する
ファクトリはライフサイクルの初期に置いて役割を果たしてきたが、一旦永続化されたから、オブジェクトを再構成するときも使われる（`今は、リポジトリの役目だと思っている`）
再構成に使われるファクトリは、生成ようとは２つ大きな違いがある
* IDを新しく割り当てない
* 不変条件違反を違う形で処理する









## リポジトリ(Repositories) 
オブジェクトの参照を得る手段は、関連をたどる、データベースを直接検索するの２つの手段がある

データベースで直接参照を取得すると、不変条件の保証とかできない




###  わからない事
*  再構成に使うファクトリとリポジトリの使い分け
というか何が違うか不明

* 誰かが集約をランタイムに持ってきたとき、違う人がリポジトリにファインどしたら同じ参照を取るべきなのか、田舎その時の実装は？

