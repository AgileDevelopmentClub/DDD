# 6.ドメインオブジェクトのライフサイクル

ライフサイクルとは
生成、修正、格納、再構成、アーカイブ、削除とうの状態遷移のこと

### 課題
1. ライフサイクルを通して整合性を維持すること
2. ライフサイクル管理が複雑でも、モデルを侵食しないこと
   
これらを解決するテクニックとして本章では以下３つの概念を説明する

---

## 6.1集約(Aggregates)
---
### 6.2 どんなもの？
* 密接に関連するオブジェクト間の不変条件をカプセル化する物
* ドメインオブジェクトのトランザクションを制御する範囲
* 複雑な関連を伴うモデルではオブジェクトの一貫性を保証するのが難しい
（慎重にロックしすぎると全然更新できないし、ロックをしないと一貫性が保証できない）＜＝　関連はなるべく少なくなるようにモデリングすべき

### 6.3 集約である条件
* 集約のルートエンティティはグローバルな同一性をもち、不変条件を維持する責任をもつ
* 集約内部のエンティティは集約内部でのみ一意となるローカルな同一性をもつ
* 集約の境界外のオブジェクトは集約のルート以外の参照を保持できない
* 集約内部のオブジェクトは他の集約ルートの参照を保持できる`今の所理解できない`
* 削除の操作は集約内に存在するあらゆるものを一度に削除しなければならない
* 集約内部のオブジェクトが変更がコミットされる場合、集約全体の不変条件が維持されなければならない
  
--- 
## 6.2 ファクトリ（Factory）
---
ライフサイクルの初期を担う  
複雑な集約を作成する操作を集約自体に持たせると、集約が複雑かする
だからと言ってAP層に持たせるとドメインの知識がドメインから流出してしまう
複雑な集約の作成をカプセル化するのにファクトリを用いる

### 6.2.2 ファクトリの要件
* 生成操作はアトミックにすること（不変条件を満たしている）
* ファクトリは生成される具象クラスではなく、要求される型に応じて抽象化されなければならない
  
### 6.2.3 ファクトリの場所
* 集約のルートにファクトリメソッドとして定義
* 他のオブジェクトの生成に密接に関わるオブジェクトにファクトリメソッドを置く

### 6.2.4 コンストラクタで良いケース
* クラスが（type）である(多態がない)
* クライアントが実装に関心がある（ストラテジーを選択する方法の場合）
* オブジェクトの持つ属性を全てクライアントが取得できるため、クライアントが目にするコンストラクタの内部に別のオブジェクトがネストされることがない
* 構築が複雑でない

### 6.2.5 IFの設計
* `各操作はアトミックでなければならない`  
不変条件が満たせなかったときにどうなるか、決める必要あり
（NULLを返すのか、例外を出すのか。コーディング基準を決めるとべき）

* `ファクトリはその引数と結合する`  
入力パラメータと深く結合するので、慎重にパラメータを決める
なるべくパラメータは抽象化すること

### 6.2.5 不変条件のロジックはどこに置くべきか
* ファクトリは不変条件の検証を生成物に委譲できる


  
### 6.2.6 エンティティファクトリと値オブジェクトファクトリの違い
* 値オブジェクトファクトリはオブジェクトを完全な状態で作成する必要があるが、エンティティファクトリは不変条件さえ満たしていれば、あとは大丈夫


### 6.2.7 格納したオブジェクトを再構成する
気合の入ったORマッパーを使うなら、再構成はファクトリを使う必要は薄い？
* ファクトリはライフサイクルの初期に置いて役割を果たしてきたが、一旦永続化されたから、オブジェクトを再構成するときも使われる（`今は、リポジトリの役目だと思っている`）
再構成に使われるファクトリは、生成ようとは２つ大きな違いがある
* IDを新しく割り当てない
* 不変条件違反を違う形で処理する



--- 

## 6.3 リポジトリ(Repositories) 
---

### 6.3.1 どんなもの
* オブジェクトのコレクションがメモリ上に存在すると錯覚させるもの
* 集約のルートに対してのみ、リポジトリを作る

### 6.3.2 メリット
* アプリケーションを永続化技術から、分離する
* オブジェクトアクセスに関する設計上の決定を伝える
* テスト用のダミー実装が簡単になる

オブジェクトの参照を得る手段は、関連をたどる、データベースを直接検索するの２つの手段がある  
データベースで直接参照を取得すると、不変条件の保証とかできない

### 6.3.3 実装上の懸案
* 型を抽象化する
* トランザクションの制御はクライアントに委ねる

### 6.3.4 リレーショナルDBに合わせてオブジェクトを設計する
RDBがAPに使用されるケースは３パターンある

1. オブジェクトを格納することが主たる目的
2. 別のシステムのために設計されている
3. オブジェクトを格納すること以外の役割を果たしている

* １の場合は、外部プロセスからアクセスさせないようにすることで、モデルの不変条件を守りやすくなる
* 2,3　の場合は１４章で掘り下げる（概念的には２種類のドメインモデルが共存している）



###  わからない事
*  再構成に使うファクトリとリポジトリの使い分け
というか何が違うか不明 = > 結論でず

* 誰かが集約をランタイムに持ってきたとき、違う人がリポジトリにファインどしたら同じ参照を取るべきなのかいなか、その時の実装は？
  ＝＞　

* 集約内部のオブジェクトは他の集約ルートの参照を保持できる
どいういう風に実装する？
例えば、車が集約のルートだとしてエンジンはどんなファクトリになるのか？どうやって車に保持させるのか？

* ファクトリが必要ない（コンストラクタで良い条件）クラスが（type）である（`よくわからん`）
オブジェクトの持つ属性を全てクライアントが取得できるため、クライアントが目にするコンストラクタの内部に別のオブジェクトがネストされることがない（`意味不明`）

* ファクトリを置く場所（「全く魅力を感じない」＜＝`意味不明`）

* 再構成にファクトリを使うか、リポジトリを使うかの区別ができていない
